<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Mixed Tenses Trainer ‚Äî Master all 12 English tenses: Present, Past & Future (Simple, Continuous, Perfect, Perfect Continuous). 10 progressive levels."
    />
    <title>Mixed Tenses Trainer | English Trainers</title>

    <!-- Preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <!-- CSS -->
    <link rel="stylesheet" href="assets/css/core.css" />
    <link rel="stylesheet" href="assets/css/components.css" />
    <link rel="stylesheet" href="assets/css/trainers.css" />
    <link rel="stylesheet" href="assets/css/mixed-tenses.css" />
    <link rel="stylesheet" href="assets/css/textbook.css" /> <!-- Textbook Styles -->
    <link rel="stylesheet" href="assets/css/effects.css" />

    <!-- Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <!-- Header -->
    <header class="trainer-header">
      <div class="container">
        <a href="index.html" class="back-btn" aria-label="–ù–∞–∑–∞–¥ –≤ –ø–æ—Ä—Ç–∞–ª">
          ‚Üê –ü–æ—Ä—Ç–∞–ª
        </a>
        <h1>üéØ –¢—Ä–µ–Ω–∞–∂–µ—Ä –í—Ä–µ–º–µ–Ω</h1>
        <button class="btn btn-secondary" id="open-textbook-btn" title="–û—Ç–∫—Ä—ã—Ç—å —É—á–µ–±–Ω–∏–∫" style="margin-left: auto; gap: 0.5rem;">
          üìñ –¢–µ–æ—Ä–∏—è
        </button>
        <p class="subtitle">–ú–∞—Å—Ç–µ—Ä –≤—Å–µ—Ö 12 –∞–Ω–≥–ª–∏–π—Å–∫–∏—Ö –≤—Ä–µ–º–µ–Ω</p>
      </div>
    </header>

    <!-- Stats Bar -->
    <div class="stats-bar" role="region" aria-label="Game statistics">
      <div class="container">
        <div class="stat">
          <span class="label">–û—á–∫–∏</span>
          <span id="score" class="value">0</span>
        </div>
        <div id="streak" class="stat hidden">
          <span class="value">üî• 0</span>
        </div>
        <div class="stat">
          <span class="label">–ñ–∏–∑–Ω–∏</span>
          <span id="lives" class="value">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
        </div>
        <div class="stat">
          <span class="label">–£—Ä–æ–≤–µ–Ω—å</span>
          <span id="level" class="value">1</span>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <main class="container">
      <!-- Level Info -->
      <div id="level-info" class="level-info">
        <h2 id="level-title">Level 1: Basics</h2>
        <p id="level-description">Only affirmative sentences (+)</p>
        <div class="quota-display">
          <span id="quota-text">PS: 5, PC: 5, PP: 5</span>
        </div>
      </div>

      <!-- Question Area -->
      <div id="question-container" class="question-container">
        <!-- Start Screen -->
        <div id="start-screen" class="start-screen">
          <div class="start-content">
            <div class="emoji" style="font-size: 4rem">üéØ</div>
            <h2>–ì–æ—Ç–æ–≤—ã –∫ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ?</h2>
            <p style="color: var(--text-muted); margin: 0.5rem 0 1.5rem">
              –û—Å–≤–æ–π—Ç–µ –≤—Å–µ 12 –∞–Ω–≥–ª–∏–π—Å–∫–∏—Ö –≤—Ä–µ–º–µ–Ω!
            </p>

            <!-- TAB SWITCHER -->
            <div class="tab-switcher">
              <button class="tab-btn active" data-tab="levels">üìã –£—Ä–æ–≤–Ω–∏</button>
              <button class="tab-btn" data-tab="custom">üõ†Ô∏è –°–≤–æ–π —Ä–µ–∂–∏–º</button>
            </div>

            <!-- TAB 1: PRESET LEVELS -->
            <div id="tab-levels" class="tab-content active">
              <div class="level-selector">
                <h3>–ù–∞—Å—Ç–æ—è—â–µ–µ (Present):</h3>
                <div class="level-buttons">
                  <button class="btn btn-secondary" data-level="present-simple" style="border: 2px solid var(--primary); background: rgba(59, 130, 246, 0.1);">
                    –¢–æ–ª—å–∫–æ<br>Present Simple<br /><small>–ë–∞–∑–æ–≤—ã–π —Å—Ç–∞—Ä—Ç (+/-/?)<br><span style="opacity:0.7; font-size:0.8em">–§–∞–∫—Ç—ã, –ø—Ä–∏–≤—ã—á–∫–∏</span></small>
                  </button>
                  <button class="btn btn-secondary" data-level="1">
                    –£—Ä–æ–≤–µ–Ω—å 1<br /><small>–û—Å–Ω–æ–≤—ã Present (+)<br><span style="opacity:0.7; font-size:0.8em">PS, PC, PP (—Ç–æ–ª—å–∫–æ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è)</span></small>
                  </button>
                  <button class="btn btn-secondary" data-level="2">
                    –£—Ä–æ–≤–µ–Ω—å 2<br /><small>–û—Ç—Ä–∏—Ü–∞–Ω–∏—è (-)<br><span style="opacity:0.7; font-size:0.8em">Present: –£—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è + –û—Ç—Ä–∏—Ü–∞–Ω–∏—è</span></small>
                  </button>
                  <button class="btn btn-secondary" data-level="3">
                    –£—Ä–æ–≤–µ–Ω—å 3<br /><small>–ú–∞—Å—Ç–µ—Ä Present<br><span style="opacity:0.7; font-size:0.8em">–ü–æ–ª–Ω—ã–π –º–∏–∫—Å (+ / - / ?)</span></small>
                  </button>
                </div>

                <h3 style="margin-top: 1rem">–ü—Ä–æ—à–µ–¥—à–µ–µ (Past):</h3>
                <div class="level-buttons">
                  <button class="btn btn-secondary" data-level="past-simple" style="border: 2px solid var(--primary); background: rgba(59, 130, 246, 0.1);">
                    –¢–æ–ª—å–∫–æ<br>Past Simple<br /><small>–ë–∞–∑–æ–≤—ã–π —Å—Ç–∞—Ä—Ç V2/Did<br><span style="opacity:0.7; font-size:0.8em">–ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è</span></small>
                  </button>
                  <button class="btn btn-secondary" data-level="4">
                    –£—Ä–æ–≤–µ–Ω—å 4<br /><small>–û—Å–Ω–æ–≤—ã Past (+)<br><span style="opacity:0.7; font-size:0.8em">PaS, PaC (—Ç–æ–ª—å–∫–æ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è)</span></small>
                  </button>
                  <button class="btn btn-secondary" data-level="5">
                    –£—Ä–æ–≤–µ–Ω—å 5<br /><small>–ú–∞—Å—Ç–µ—Ä Past<br><span style="opacity:0.7; font-size:0.8em">PaS, PaC, PaP (+ / - / ?)</span></small>
                  </button>
                </div>

                <h3 style="margin-top: 1rem">–ë—É–¥—É—â–µ–µ (Future):</h3>
                <div class="level-buttons">
                  <button class="btn btn-secondary" data-level="future-simple" style="border: 2px solid var(--primary); background: rgba(59, 130, 246, 0.1);">
                    –¢–æ–ª—å–∫–æ<br>Future Simple<br /><small>–ë–∞–∑–æ–≤—ã–π —Å—Ç–∞—Ä—Ç Will<br><span style="opacity:0.7; font-size:0.8em">–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è, —Ä–µ—à–µ–Ω–∏—è</span></small>
                  </button>
                  <button class="btn btn-secondary" data-level="6">
                    –£—Ä–æ–≤–µ–Ω—å 6<br /><small>–û—Å–Ω–æ–≤—ã Future (+)<br><span style="opacity:0.7; font-size:0.8em">FS, FC (—Ç–æ–ª—å–∫–æ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è)</span></small>
                  </button>
                  <button class="btn btn-secondary" data-level="7">
                    –£—Ä–æ–≤–µ–Ω—å 7<br /><small>–ú–∞—Å—Ç–µ—Ä Future<br><span style="opacity:0.7; font-size:0.8em">FS, FC, FP (+ / - / ?)</span></small>
                  </button>
                </div>

                <h3 style="margin-top: 1rem">–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π (Perfect):</h3>
                <div class="level-buttons">
                  <button class="btn btn-secondary" data-level="8">
                    –£—Ä–æ–≤–µ–Ω—å 8<br /><small>–í–≤–µ–¥–µ–Ω–∏–µ –≤ Profi (+)<br><span style="opacity:0.7; font-size:0.8em">PPC, PaPC (Perfect Continuous)</span></small>
                  </button>
                  <button class="btn btn-secondary" data-level="9">
                    –£—Ä–æ–≤–µ–Ω—å 9<br /><small>–ú–∞—Å—Ç–µ—Ä Profi<br><span style="opacity:0.7; font-size:0.8em">–í—Å–µ —Å–ª–æ–∂–Ω—ã–µ –≤—Ä–µ–º–µ–Ω–∞ (Hard)</span></small>
                  </button>
                </div>

                <h3 style="margin-top: 1rem">–ò—Å–ø—ã—Ç–∞–Ω–∏–µ:</h3>
                <div class="level-buttons">
                  <button class="btn btn-secondary" data-level="10">
                    –£—Ä–æ–≤–µ–Ω—å 10<br /><small>Grand Mix üåÄ<br><span style="opacity:0.7; font-size:0.8em">–í—Å–µ 12 –≤—Ä–µ–º–µ–Ω —Å—Ä–∞–∑—É</span></small>
                  </button>
                  <button class="btn btn-secondary" data-level="hard">
                    Hardcore<br /><small>–°–ª–æ–∂–Ω—ã–π —Ä–µ–∂–∏–º üî•<br><span style="opacity:0.7; font-size:0.8em">–¢–æ–ª—å–∫–æ (?) –∏ (-), —Å–ª–æ–∂–Ω—ã–µ —Ç–∏–ø—ã</span></small>
                  </button>
                  <button class="btn btn-primary" data-level="exam">
                    –≠–ö–ó–ê–ú–ï–ù<br /><small>60 –í–æ–ø—Ä–æ—Å–æ–≤ üèÜ</small>
                  </button>
                </div>
              </div>
            </div>

            <!-- TAB 2: CUSTOM BUILDER -->
            <div id="tab-custom" class="tab-content">
              <div class="custom-builder">
                <!-- TENSE SELECTION GRID -->
                <div class="builder-section">
                  <h3>üéØ –í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º–µ–Ω–∞ <span class="tense-counter" id="tense-counter">(0)</span></h3>
                  <div class="tense-grid">
                    <!-- Header row -->
                    <div class="tense-grid-header"></div>
                    <div class="tense-grid-header">Simple</div>
                    <div class="tense-grid-header">Cont.</div>
                    <div class="tense-grid-header">Perfect</div>
                    <div class="tense-grid-header">Perf. Cont.</div>

                    <!-- Present row -->
                    <div class="tense-row-label">Present</div>
                    <label class="tense-check">
                      <input type="checkbox" name="tense" value="present-simple" />
                      <span class="check-label">PS</span>
                    </label>
                    <label class="tense-check">
                      <input type="checkbox" name="tense" value="present-continuous" />
                      <span class="check-label">PC</span>
                    </label>
                    <label class="tense-check">
                      <input type="checkbox" name="tense" value="present-perfect" />
                      <span class="check-label">PP</span>
                    </label>
                    <label class="tense-check">
                      <input type="checkbox" name="tense" value="present-perfect-continuous" />
                      <span class="check-label">PPC</span>
                    </label>

                    <!-- Past row -->
                    <div class="tense-row-label">Past</div>
                    <label class="tense-check">
                      <input type="checkbox" name="tense" value="past-simple" />
                      <span class="check-label">PaS</span>
                    </label>
                    <label class="tense-check">
                      <input type="checkbox" name="tense" value="past-continuous" />
                      <span class="check-label">PaC</span>
                    </label>
                    <label class="tense-check">
                      <input type="checkbox" name="tense" value="past-perfect" />
                      <span class="check-label">PaP</span>
                    </label>
                    <label class="tense-check">
                      <input type="checkbox" name="tense" value="past-perfect-continuous" />
                      <span class="check-label">PaPC</span>
                    </label>

                    <!-- Future row -->
                    <div class="tense-row-label">Future</div>
                    <label class="tense-check">
                      <input type="checkbox" name="tense" value="future-simple" />
                      <span class="check-label">FS</span>
                    </label>
                    <label class="tense-check">
                      <input type="checkbox" name="tense" value="future-continuous" />
                      <span class="check-label">FC</span>
                    </label>
                    <label class="tense-check">
                      <input type="checkbox" name="tense" value="future-perfect" />
                      <span class="check-label">FP</span>
                    </label>
                    <label class="tense-check">
                      <input type="checkbox" name="tense" value="future-perfect-continuous" />
                      <span class="check-label">FPC</span>
                    </label>
                  </div>

                  <!-- Quick select buttons -->
                  <div class="quick-select">
                    <button type="button" class="qs-btn" data-select="all-present">–í—Å–µ Present</button>
                    <button type="button" class="qs-btn" data-select="all-past">–í—Å–µ Past</button>
                    <button type="button" class="qs-btn" data-select="all-future">–í—Å–µ Future</button>
                    <button type="button" class="qs-btn" data-select="all-simple">Simple</button>
                    <button type="button" class="qs-btn" data-select="all-continuous">Continuous</button>
                    <button type="button" class="qs-btn" data-select="all-perfect">Perfect</button>
                    <button type="button" class="qs-btn" data-select="all">–í—ã–±—Ä–∞—Ç—å –≤—Å–µ</button>
                    <button type="button" class="qs-btn qs-btn-clear" data-select="none">–°–±—Ä–æ—Å</button>
                  </div>
                </div>

                <!-- SENTENCE TYPES -->
                <div class="builder-section">
                  <h3>üìù –¢–∏–ø—ã –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π</h3>
                  <div class="toggle-row">
                    <label class="toggle-check">
                      <input type="checkbox" name="stype" value="affirmative" checked />
                      <span class="toggle-label">‚úÖ –£—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ (+)</span>
                    </label>
                    <label class="toggle-check">
                      <input type="checkbox" name="stype" value="negative" checked />
                      <span class="toggle-label">‚ùå –û—Ç—Ä–∏—Ü–∞–Ω–∏–µ (-)</span>
                    </label>
                    <label class="toggle-check">
                      <input type="checkbox" name="stype" value="question" checked />
                      <span class="toggle-label">‚ùì –í–æ–ø—Ä–æ—Å (?)</span>
                    </label>
                  </div>
                </div>

                <!-- TASK TYPES -->
                <div class="builder-section">
                  <h3>üß© –¢–∏–ø—ã –∑–∞–¥–∞–Ω–∏–π</h3>
                  <div class="toggle-row">
                    <label class="toggle-check">
                      <input type="checkbox" name="ttype" value="gap" checked />
                      <span class="toggle-label">üìù –í–ø–∏—Å–∞—Ç—å —Å–ª–æ–≤–æ</span>
                    </label>
                    <label class="toggle-check">
                      <input type="checkbox" name="ttype" value="choice" checked />
                      <span class="toggle-label">üîò –í—ã–±–æ—Ä –æ—Ç–≤–µ—Ç–∞</span>
                    </label>
                    <label class="toggle-check">
                      <input type="checkbox" name="ttype" value="error" checked />
                      <span class="toggle-label">üîç –ù–∞–π—Ç–∏ –æ—à–∏–±–∫—É</span>
                    </label>
                  </div>
                </div>

                <!-- QUESTIONS PER TENSE -->
                <div class="builder-section">
                  <h3>üî¢ –í–æ–ø—Ä–æ—Å–æ–≤ –Ω–∞ –∫–∞–∂–¥–æ–µ –≤—Ä–µ–º—è: <span id="qpt-value" class="slider-value">5</span></h3>
                  <input type="range" id="qpt-slider" min="2" max="15" value="5" class="custom-slider" />
                  <div class="slider-labels">
                    <span>2</span><span>5</span><span>10</span><span>15</span>
                  </div>
                </div>

                <!-- SUMMARY & START -->
                <div class="builder-summary" id="builder-summary">
                  <span id="summary-text">–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã 2 –≤—Ä–µ–º–µ–Ω–∏</span>
                </div>
                <button class="btn btn-primary btn-custom-start" id="custom-start-btn" disabled>
                  üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="game-screen" style="display: none">
          <div class="question-card">
            <div id="question-text" class="question-text"></div>

            <!-- Standard Options -->
            <div id="options-standard" class="options-grid">
              <button class="option-btn" data-option="0"></button>
              <button class="option-btn" data-option="1"></button>
              <button class="option-btn" data-option="2"></button>
            </div>

            <!-- Find Error Options -->
            <div id="options-error" class="error-options" style="display: none">
              <p class="error-instruction">
                Click on the word that has a mistake:
              </p>
              <div id="error-words" class="error-words"></div>
            </div>

            <!-- Feedback -->
            <div id="feedback" class="feedback" style="display: none">
              <div id="feedback-icon" class="feedback-icon"></div>
              <div id="feedback-text" class="feedback-text"></div>
            </div>
          </div>

          <!-- Controls -->
          <div class="game-controls">
            <button class="control-btn hint-btn" id="hint-btn">
              üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞
            </button>
            <button class="control-btn next-btn" id="next-btn" style="display: none">
              –î–∞–ª–µ–µ ‚Üí
            </button>
          </div>
        </div>

        <!-- Results Screen -->
        <div id="results-screen" class="results-screen" style="display: none">
          <div class="results-card">
            <h2>üéâ –£—Ä–æ–≤–µ–Ω—å –ü—Ä–æ–π–¥–µ–Ω!</h2>
            
            <div class="stats-grid">
              <div class="stat-item">
                <span class="stat-label">–í–æ–ø—Ä–æ—Å—ã</span>
                <span id="results-questions" class="stat-value">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">–ü—Ä–∞–≤–∏–ª—å–Ω–æ</span>
                <span id="results-correct" class="stat-value">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">–¢–æ—á–Ω–æ—Å—Ç—å</span>
                <span id="results-accuracy" class="stat-value">0%</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">–°–µ—Ä–∏—è</span>
                <span id="results-streak" class="stat-value">0</span>
              </div>
            </div>

            <div class="results-actions">
              <button class="btn btn-secondary" id="finish-btn">–ú–µ–Ω—é</button>
              <button class="btn btn-primary" id="retry-btn">–ü–æ–≤—Ç–æ—Ä–∏—Ç—å ‚Ü∫</button>
              <button class="btn btn-primary" id="next-level-btn">–î–∞–ª–µ–µ ‚Üí</button>
            </div>
          </div>
        </div>
      </div>
    </main>

    <!-- Scripts -->
    <script src="assets/js/trainer-core.js"></script>
    <script src="assets/js/trainer-ui.js"></script>
    <script src="assets/js/trainer-timer-tts.js"></script>
    <script src="assets/js/trainer-dom-events-utils.js"></script>
    <script src="assets/js/effects/EffectsManager.js"></script>
    <script src="assets/js/effects/AuroraEffect.js"></script>
    <script src="assets/js/effects/AudioEffectsManager.js"></script>
    <script src="assets/js/effects/HapticFeedback.js"></script>

    <script type="module">
      import MixedTrainer from "./assets/js/modules/mixed-tenses.js";
      import { TextbookModal } from "./assets/js/modules/textbook.js";

      class MixedTensesUI {
        constructor() {
          this.trainer = null;
          this.elements = {};
          this.currentQuestion = null;
          this.startConfig = null;
          this.textbook = new TextbookModal();
          
          this.init();
        }

        init() {
          this.elements = this.cacheElements();
          this.bindEvents();
          
          this.textbook.init();
          this.textbook.onStartPractice = (config) => {
               this.startGame(config);
          };
        }
        cacheElements() {
          return {
            startScreen: document.getElementById("start-screen"),
            gameScreen: document.getElementById("game-screen"),
            resultsScreen: document.getElementById("results-screen"),
            levelInfo: document.getElementById("level-info"),
            levelTitle: document.getElementById("level-title"),
            levelDesc: document.getElementById("level-description"),

            quotaText: document.getElementById("quota-text"),
            questionText: document.getElementById("question-text"),
            optionsStandard: document.getElementById("options-standard"),
            optionsError: document.getElementById("options-error"),
            errorWords: document.getElementById("error-words"),
            feedback: document.getElementById("feedback"),
            feedbackIcon: document.getElementById("feedback-icon"),
            feedbackText: document.getElementById("feedback-text"),
            hintBtn: document.getElementById("hint-btn"),
            nextBtn: document.getElementById("next-btn"),
            score: document.getElementById("score"),
            lives: document.getElementById("lives"),
            level: document.getElementById("level"),
            streak: document.getElementById("streak"),
          };
        }

        bindEvents() {
          // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê TAB SWITCHING ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          const tabBtns = document.querySelectorAll('.tab-btn');
          const tabContents = document.querySelectorAll('.tab-content');
          tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
              tabBtns.forEach(b => b.classList.remove('active'));
              tabContents.forEach(c => c.classList.remove('active'));
              btn.classList.add('active');
              document.getElementById(`tab-${btn.dataset.tab}`).classList.add('active');
            });
          });

          // Textbook Button
          const tbBtn = document.getElementById('open-textbook-btn');
          if (tbBtn) {
            tbBtn.addEventListener('click', () => {
                console.log("Textbook button clicked, attempting to open present-simple");
                // Default to present-simple for now, or detect context
                this.textbook.open('present-simple');
            });
          }

          // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê LEVEL SELECTION (preset) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          document.querySelectorAll("[data-level]").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const level = e.target.closest("[data-level]").dataset.level;
              this.startGame(level);
            });
          });

          // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê CUSTOM BUILDER ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          const tenseCheckboxes = document.querySelectorAll('input[name="tense"]');
          const stypeCheckboxes = document.querySelectorAll('input[name="stype"]');
          const ttypeCheckboxes = document.querySelectorAll('input[name="ttype"]');
          const qptSlider = document.getElementById('qpt-slider');
          const qptValue = document.getElementById('qpt-value');
          const summaryText = document.getElementById('summary-text');
          const customStartBtn = document.getElementById('custom-start-btn');
          const tenseCounter = document.getElementById('tense-counter');

          const updateSummary = () => {
            const selected = [...tenseCheckboxes].filter(c => c.checked).map(c => c.value);
            const stypes = [...stypeCheckboxes].filter(c => c.checked).map(c => c.value);
            const ttypes = [...ttypeCheckboxes].filter(c => c.checked).map(c => c.value);
            const qpt = parseInt(qptSlider.value);

            tenseCounter.textContent = `(${selected.length} selected)`;
            qptValue.textContent = qpt;

            if (selected.length < 1) {
              summaryText.textContent = '–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã 1 –≤—Ä–µ–º—è';
              customStartBtn.disabled = true;
              return;
            }
            if (stypes.length === 0) {
              summaryText.textContent = '–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã 1 —Ç–∏–ø –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π';
              customStartBtn.disabled = true;
              return;
            }
            if (ttypes.length === 0) {
              summaryText.textContent = '–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã 1 —Ç–∏–ø –∑–∞–¥–∞–Ω–∏–π';
              customStartBtn.disabled = true;
              return;
            }

            const total = selected.length * qpt;
            summaryText.innerHTML = `<strong>${selected.length}</strong> –≤—Ä–µ–º–µ–Ω √ó <strong>${qpt}</strong> –≤–æ–ø—Ä–æ—Å–æ–≤ = <strong>${total} –≤—Å–µ–≥–æ</strong>`;
            customStartBtn.disabled = false;
          };

          tenseCheckboxes.forEach(c => c.addEventListener('change', updateSummary));
          stypeCheckboxes.forEach(c => c.addEventListener('change', updateSummary));
          ttypeCheckboxes.forEach(c => c.addEventListener('change', updateSummary));
          qptSlider.addEventListener('input', updateSummary);

          // Quick Select buttons
          document.querySelectorAll('.qs-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              const action = btn.dataset.select;
              const GROUPS = {
                'all-present': v => v.startsWith('present'),
                'all-past': v => v.startsWith('past'),
                'all-future': v => v.startsWith('future'),
                'all-simple': v => v.endsWith('-simple'),
                'all-continuous': v => v.includes('continuous') && !v.includes('perfect'),
                'all-perfect': v => v.includes('perfect'),
                'all': () => true,
                'none': () => false,
              };
              const filterFn = GROUPS[action];
              if (!filterFn) return;

              if (action === 'none') {
                tenseCheckboxes.forEach(c => c.checked = false);
              } else {
                tenseCheckboxes.forEach(c => {
                  if (filterFn(c.value)) c.checked = true;
                });
              }
              updateSummary();
            });
          });

          // Custom Start button
          customStartBtn.addEventListener('click', () => {
            const selected = [...tenseCheckboxes].filter(c => c.checked).map(c => c.value);
            const stypes = [...stypeCheckboxes].filter(c => c.checked).map(c => c.value);
            const ttypes = [...ttypeCheckboxes].filter(c => c.checked).map(c => c.value);
            const qpt = parseInt(qptSlider.value);

            const quota = {};
            selected.forEach(t => quota[t] = qpt);

            const ABBR = {
              'present-simple': 'PS', 'present-continuous': 'PC',
              'present-perfect': 'PP', 'present-perfect-continuous': 'PPC',
              'past-simple': 'PaS', 'past-continuous': 'PaC',
              'past-perfect': 'PaP', 'past-perfect-continuous': 'PaPC',
              'future-simple': 'FS', 'future-continuous': 'FC',
              'future-perfect': 'FP', 'future-perfect-continuous': 'FPC',
            };
            const tenseNames = selected.map(t => ABBR[t] || t).join(' + ');

            this.startGame({
              custom: true,
              title: `–°–≤–æ–π —Ä–µ–∂–∏–º: ${tenseNames}`,
              description: `${selected.length} –í—Ä–µ–º–µ–Ω √ó ${qpt} –í–æ–ø—Ä–æ—Å–æ–≤`,
              quota,
              allowedTypes: stypes,
              allowedTasks: ttypes,
            });
          });

          // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ANSWER / CONTROL BUTTONS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          // Answer buttons
          this.elements.optionsStandard.addEventListener("click", (e) => {
            if (e.target.classList.contains("option-btn")) {
              const optionIndex = parseInt(e.target.dataset.option);
              this.submitAnswer(optionIndex);
            }
          });

          // Error finding buttons
          this.elements.errorWords.addEventListener("click", (e) => {
            if (e.target.classList.contains("error-word")) {
              const optionIndex = parseInt(e.target.dataset.option);
              this.submitAnswer(optionIndex);
            }
          });

          // Control buttons
          this.elements.hintBtn.addEventListener("click", () =>
            this.showHint(),
          );
          this.elements.nextBtn.addEventListener("click", () =>
            this.nextQuestion(),
          );

          // Results buttons
          document
            .getElementById("retry-btn")
            .addEventListener("click", () => this.retryLevel());
          document
            .getElementById("next-level-btn")
            .addEventListener("click", () => this.nextLevel());
          document
            .getElementById("finish-btn")
            .addEventListener("click", () => this.finishGame());
        }



        async loadNextQuestion() {
          try {
            this.currentQuestion = await this.trainer.generateQuestion();

            if (this.currentQuestion.finished) {
              this.showResults(this.currentQuestion.stats);
              return;
            }

            this.renderQuestion();
            this.updateUI();
          } catch (error) {
            console.error("Error loading question:", error);
            this.showError("Failed to load question");
          }
        }

        renderQuestion() {
          const q = this.currentQuestion;

          // Clean up and localize instructions
          let instruction = "";
          let questionText = q.question;

          // Clean up raw generator output
          if (q.type === "choice") {
            instruction = "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç:";
            questionText = questionText.replace(
              /^Choose correct[^:]*:\s*/i,
              "",
            );
          } else if (q.type === "gap") {
            instruction = "–î–æ–ø–æ–ª–Ω–∏—Ç–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ:";
          } else if (q.type === "find_error") {
            instruction = "–ù–∞–π–¥–∏—Ç–µ –æ—à–∏–±–∫—É:";
            // questionText now contains the full sentence from generator
          }

          // Render with proper hierarchy
          this.elements.questionText.innerHTML =
            `<span style="display:block; font-size: 0.9em; color: var(--text-muted); margin-bottom: 0.5rem;">${instruction}</span>` +
            `<span style="display:block; font-size: 1.4em; font-weight: bold;">${questionText}</span>`;

          // Hide feedback
          this.elements.feedback.style.display = "none";
          this.elements.nextBtn.style.display = "none";
          this.elements.hintBtn.style.display = "inline-block";

          if (q.type === "find_error") {
            // Find error mode
            this.elements.optionsStandard.style.display = "none";
            this.elements.optionsError.style.display = "block";

            this.elements.errorWords.innerHTML = q.options
              .map(
                (option, index) => `
            <button class="error-word" data-option="${index}">
              ${option.text}
            </button>
          `,
              )
              .join("");
          } else {
            // Standard mode
            this.elements.optionsStandard.style.display = "grid";
            this.elements.optionsError.style.display = "none";

            const buttons =
              this.elements.optionsStandard.querySelectorAll(".option-btn");
            q.options.forEach((option, index) => {
              if (buttons[index]) {
                buttons[index].textContent = option;
                buttons[index].disabled = false;
                buttons[index].classList.remove("correct", "wrong");
              }
            });
          }
        }

        async submitAnswer(answerIndex) {
          const q = this.currentQuestion;
          let isCorrect = false;

          if (q.type === "find_error") {
            isCorrect = q.options[answerIndex].correct;
          } else {
            isCorrect = q.options[answerIndex] === q.correct;
          }

          // Update trainer state
          if (isCorrect) {
            this.trainer.state.score += 10;
            this.trainer.state.correctAnswers++;
            this.trainer.state.streak++;
            if (this.trainer.state.streak > this.trainer.state.maxStreak) {
              this.trainer.state.maxStreak = this.trainer.state.streak;
            }
          } else {
            this.trainer.state.lives--;
            this.trainer.state.streak = 0;
          }

          this.trainer.state.questionsAnswered++;

          // Visual feedback
          this.showFeedback(isCorrect, answerIndex);

          // Effects
          if (isCorrect) {
            this.trainer._effects.triggerSuccessEffects(
              this.trainer.state.streak,
              document.getElementById("question-container"),
            );
          } else {
            this.trainer._effects.triggerErrorEffects();
          }

          // Update UI
          this.updateUI();

          // Check game over
          if (this.trainer.state.lives <= 0) {
            setTimeout(() => {
              this.showResults(this.trainer.getStats());
            }, 2000);
            return;
          }

          // Show next button after delay
          setTimeout(() => {
            this.elements.nextBtn.style.display = "inline-block";
          }, 1500);
        }

        showFeedback(isCorrect, selectedIndex) {
          this.elements.feedback.style.display = "block";

          if (isCorrect) {
            this.elements.feedbackIcon.textContent = "‚úÖ";
            this.elements.feedbackText.textContent = "Correct!";
            this.elements.feedback.className = "feedback correct";

            // Highlight correct answer
            if (this.currentQuestion.type === "find_error") {
              const correctBtn = this.elements.errorWords.querySelector(
                `[data-option="${selectedIndex}"]`,
              );
              if (correctBtn) correctBtn.classList.add("correct");
            } else {
              const correctBtn = this.elements.optionsStandard.querySelector(
                `[data-option="${selectedIndex}"]`,
              );
              if (correctBtn) correctBtn.classList.add("correct");
            }
          } else {
            this.elements.feedbackIcon.textContent = "‚ùå";
            this.elements.feedbackText.textContent = "Incorrect!";
            this.elements.feedback.className = "feedback wrong";

            // Highlight wrong answer and show correct one
            if (this.currentQuestion.type === "find_error") {
              const wrongBtn = this.elements.errorWords.querySelector(
                `[data-option="${selectedIndex}"]`,
              );
              if (wrongBtn) wrongBtn.classList.add("wrong");

              // Show correct answer
              this.currentQuestion.options.forEach((option, index) => {
                if (option.correct) {
                  const correctBtn = this.elements.errorWords.querySelector(
                    `[data-option="${index}"]`,
                  );
                  if (correctBtn) correctBtn.classList.add("correct");
                }
              });
            } else {
              const wrongBtn = this.elements.optionsStandard.querySelector(
                `[data-option="${selectedIndex}"]`,
              );
              if (wrongBtn) wrongBtn.classList.add("wrong");

              // Show correct answer
              const correctIndex = this.currentQuestion.options.indexOf(
                this.currentQuestion.correct,
              );
              const correctBtn = this.elements.optionsStandard.querySelector(
                `[data-option="${correctIndex}"]`,
              );
              if (correctBtn) correctBtn.classList.add("correct");
            }
          }
        }

        showHint() {
          const hints = {
            'present-simple':               'Present Simple: —Ñ–∞–∫—Ç—ã, –ø—Ä–∏–≤—ã—á–∫–∏, —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ. V1 (+s).',
            'present-continuous':           'Present Continuous: –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ü–†–Ø–ú–û –°–ï–ô–ß–ê–°. am/is/are + Ving.',
            'present-perfect':              'Present Perfect: —Ä–µ–∑—É–ª—å—Ç–∞—Ç –°–ï–ô–ß–ê–°. have/has + V3.',
            'present-perfect-continuous':   'Present Perfect Continuous: –Ω–∞—á–∞–ª–æ—Å—å –≤ –ø—Ä–æ—à–ª–æ–º, –¥–ª–∏—Ç—Å—è –¥–æ —Å–∏—Ö –ø–æ—Ä. have/has been + Ving.',
            'past-simple':                  'Past Simple: —Ñ–∞–∫—Ç –≤ –ø—Ä–æ—à–ª–æ–º. V2 (ed).',
            'past-continuous':              'Past Continuous: –ø—Ä–æ—Ü–µ—Å—Å –≤ –º–æ–º–µ–Ω—Ç –≤ –ø—Ä–æ—à–ª–æ–º. was/were + Ving.',
            'past-perfect':                 'Past Perfect: –¥–µ–π—Å—Ç–≤–∏–µ –î–û –¥—Ä—É–≥–æ–≥–æ –ø—Ä–æ—à–ª–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è. had + V3.',
            'past-perfect-continuous':      'Past Perfect Continuous: –¥–ª–∏–ª–æ—Å—å –î–û –º–æ–º–µ–Ω—Ç–∞ –≤ –ø—Ä–æ—à–ª–æ–º. had been + Ving.',
            'future-simple':                'Future Simple: —Ä–µ—à–µ–Ω–∏–µ, –æ–±–µ—â–∞–Ω–∏–µ, –ø—Ä–æ–≥–Ω–æ–∑. will + V1.',
            'future-continuous':            'Future Continuous: –ø—Ä–æ—Ü–µ—Å—Å –≤ –º–æ–º–µ–Ω—Ç –≤ –±—É–¥—É—â–µ–º. will be + Ving.',
            'future-perfect':               'Future Perfect: –∑–∞–∫–æ–Ω—á–∏—Ç—Å—è –ö –º–æ–º–µ–Ω—Ç—É –≤ –±—É–¥—É—â–µ–º. will have + V3.',
            'future-perfect-continuous':    'Future Perfect Continuous: –±—É–¥–µ—Ç –¥–ª–∏—Ç—å—Å—è –î–û –º–æ–º–µ–Ω—Ç–∞ –≤ –±—É–¥—É—â–µ–º. will have been + Ving.',
          };

          const tense = this.currentQuestion.metadata?.tense;
          const hint = hints[tense] || "–í–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –≤—Ä–µ–º—è!";

          alert(`üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞: ${hint}`);
          this.trainer.state.score -= 2; // Penalty for hint
          this.updateUI();
        }

        async nextQuestion() {
          await this.loadNextQuestion();
        }

        updateUI() {
          // Update stats
          this.elements.score.textContent = this.trainer.state.score;
          this.elements.level.textContent = this.trainer.currentLevelId;

          // Update lives
          const hearts =
            "‚ù§Ô∏è".repeat(this.trainer.state.lives) +
            "üñ§".repeat(3 - this.trainer.state.lives);
          this.elements.lives.textContent = hearts;

          // Update streak
          if (this.trainer.state.streak > 0) {
            this.elements.streak.classList.remove("hidden");
            this.elements.streak.querySelector(".value").textContent =
              `üî• ${this.trainer.state.streak}`;
          } else {
            this.elements.streak.classList.add("hidden");
          }

          // Update level info
          this.updateLevelInfo();
        }

        updateLevelInfo() {
          if (!this.trainer?.config) return;

          this.elements.levelTitle.textContent = this.trainer.config.title;
          this.elements.levelDesc.textContent = this.trainer.config.description;

          // Update quota display ‚Äî dynamic for any tenses in the level
          const quota = this.trainer.quota;
          if (this.trainer.config.mode === "strict_count") {
            this.elements.quotaText.textContent = `+: ${quota.affirmative || 0}, -: ${quota.negative || 0}, ?: ${quota.question || 0}`;
          } else {
            const TENSE_ABBR = {
              'present-simple': 'PS', 'present-continuous': 'PC', 'present-perfect': 'PP', 'present-perfect-continuous': 'PPC',
              'past-simple': 'PaS', 'past-continuous': 'PaC', 'past-perfect': 'PaP', 'past-perfect-continuous': 'PaPC',
              'future-simple': 'FS', 'future-continuous': 'FC', 'future-perfect': 'FP', 'future-perfect-continuous': 'FPC',
            };
            const parts = Object.entries(quota)
              .map(
                ([tense, count]) => `${TENSE_ABBR[tense] || tense}: ${count}`,
              )
              .join(", ");
            this.elements.quotaText.textContent = parts;
          }


        }

        showResults(stats) {
          this.elements.gameScreen.style.display = "none";
          this.elements.resultsScreen.style.display = "block";

          document.getElementById("results-questions").textContent =
            stats.totalQuestions;
          document.getElementById("results-correct").textContent =
            stats.correctAnswers;
          document.getElementById("results-accuracy").textContent =
            `${stats.accuracy}%`;
          document.getElementById("results-streak").textContent =
            stats.bestStreak;
        }

        async startGame(levelOrConfig) {
          this.startConfig = levelOrConfig; // Save for retry

          try {
            this.trainer = new MixedTrainer(levelOrConfig);

            // Load Audio Assets
            await this.trainer._effects.loadAudioAssets({
              correct: "assets/audio/correct.mp3",
              milestone: "assets/audio/milestone.mp3",
              error: "assets/audio/error.mp3",
            });

            this.elements.startScreen.style.display = "none";
            this.elements.gameScreen.style.display = "block";
            this.updateLevelInfo();
            await this.loadNextQuestion();
          } catch (error) {
            console.error("Error starting game:", error);
            alert("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä—É: " + error.message);
          }
        }

        retryLevel() {
            if (this.startConfig && this.startConfig.custom) {
                this.trainer.initCustom(this.startConfig);
            } else {
                this.trainer.initLevel(this.trainer.currentLevelId);
            }
            
            this.elements.resultsScreen.style.display = "none";
            this.elements.gameScreen.style.display = "block";
            this.loadNextQuestion();
        }

        nextLevel() {
          const nextLevel = this.trainer.config.nextLevel;
          if (nextLevel && nextLevel !== "win") {
            this.trainer.initLevel(nextLevel);
            this.elements.resultsScreen.style.display = "none";
            this.elements.gameScreen.style.display = "block";
            this.loadNextQuestion();
          } else {
            this.finishGame();
          }
        }

        finishGame() {
          // Return to start screen
          this.elements.resultsScreen.style.display = "none";
          this.elements.startScreen.style.display = "block";
        }

        showError(message) {
          alert(`–û—à–∏–±–∫–∞: ${message}`);
        }
      }

      // Initialize when DOM is ready
      document.addEventListener("DOMContentLoaded", () => {
        window.mixedTrainer = new MixedTensesUI();
      });
    </script>
  </body>
</html>
